// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 (swiftlang-6.2.0.19.9 clang-1700.3.19.1)
// swift-module-flags: -target x86_64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -enable-upcoming-feature InferIsolatedConformances -enable-upcoming-feature NonisolatedNonsendingByDefault -enable-experimental-feature DebugDescriptionMacro -module-name IdsvrHaapiDriver
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import Combine
import CommonCrypto
import Compression
import CryptoKit
import DeviceCheck
import Foundation
import LocalAuthentication
import OSLog
import Security
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public protocol Masking {
  var masked: Swift.String { get }
}
extension Swift.String : IdsvrHaapiDriver.Masking {
  public var masked: Swift.String {
    get
  }
}
extension ObjectiveC.NSObject : IdsvrHaapiDriver.Masking {
  public var masked: Swift.String {
    get
  }
}
extension Foundation.URL : IdsvrHaapiDriver.Masking {
  public var masked: Swift.String {
    get
  }
}
extension Foundation.Data : IdsvrHaapiDriver.Masking {
  public var masked: Swift.String {
    get
  }
}
extension Swift.Dictionary : IdsvrHaapiDriver.Masking where Key == Swift.String {
  public var masked: Swift.String {
    get
  }
}
extension Foundation.URLRequest : IdsvrHaapiDriver.Masking {
  public var masked: Swift.String {
    get
  }
}
extension Swift.String {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func optionalData(_ data: Foundation.Data?, encoding: Swift.String.Encoding = .utf8, fallback: Swift.String = "") -> Swift.String
  #endif
  public var maskedPrefix: Swift.String {
    get
  }
}
@available(iOS 13.0, *)
extension Swift.StringProtocol {
  public var sha256Hex: Swift.String {
    get
  }
  public var dataUtf8Encoding: Foundation.Data {
    get
  }
  public var base64URLEncodedStringOfSHA256Hash: Swift.String {
    get
  }
}
extension Foundation.Data {
  #if compiler(>=5.3) && $NonescapableTypes
  public var stringUtf8Encoding: Swift.String? {
    get
  }
  #endif
}
@objc @_inheritsConvenienceInitializers public class Haapi : ObjectiveC.NSObject {
  @objc public static var isSupported: Swift.Bool {
    @objc get
  }
  @available(*, unavailable)
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 14, *)
public enum HaapiError : IdsvrHaapiDriver.IdsvrError, Swift.Error, Swift.Sendable {
  case communication(message: Swift.String, cause: (any Swift.Error)? = nil)
  case serverError(_: Swift.String, errorDescription: Swift.String, statusCode: Swift.Int)
  @available(*, deprecated, message: "This case is being replaced by `serverError`.")
  case invalidStatusCode(_: Swift.Int)
  case invalidURLResponse(_: Foundation.URLResponse?, reason: Swift.String, cause: (any Swift.Error)? = nil)
  case attestationNotSupported
  case attestationFailure(cause: (any Swift.Error)? = nil)
  case attestationKeyGenFailure(cause: (any Swift.Error)? = nil)
  case attestationRefusedByServer(cause: (any Swift.Error)? = nil)
  case assertionFailure(cause: (any Swift.Error)? = nil)
  case dpopKeyCreationFailure(cause: any Swift.Error)
  case dpopProofCreationFailure(cause: any Swift.Error)
  case dpopProofFailure(message: Swift.String, cause: any Swift.Error)
  case haapiTokenManagerIsClosed
  case haapiTokenManagerIsExpired
  case illegalState(message: Swift.String)
  case invalidConfiguration(reason: Swift.String)
  case haapiTokenManagerAlreadyExists(name: Swift.String)
  public var failureReason: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
  public var error: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var cause: (any Swift.Error)? {
    get
  }
  #endif
  public var recoverySuggestion: IdsvrHaapiDriver.IdsvrErrorHandling {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 14, *)
final public class KeychainStorage : IdsvrHaapiDriver.Storage {
  final public func write(key: Swift.String, data: Foundation.Data) throws
  #if compiler(>=5.3) && $NonescapableTypes
  final public func read(key: Swift.String) throws -> Foundation.Data?
  #endif
  final public func delete(key: Swift.String) throws
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @available(iOS 14, *)
@objcMembers final public class Dpop : ObjectiveC.NSObject, Swift.Codable, Swift.Sendable {
  @objc final public var jwkThumbprint: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  final public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
  @objc @available(swift, obsoleted: 0.1, message: "Use `createProof(httpMethod: String, url: URL, nonce: String?, accessToken: String?)` instead")
  final public func createProof(httpMethod: Swift.String, url: Foundation.URL) throws -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func createProof(httpMethod: Swift.String, url: Foundation.URL, nonce: Swift.String? = nil, accessToken: Swift.String? = nil) throws -> Swift.String
  #endif
  @objc @available(swift, obsoleted: 0.1, message: "Use `getHeaderValue(httpMethod: String, url: URL, nonce: String?, accessToken: String?)` instead")
  final public func getHeaderValue(httpMethod: Swift.String, url: Foundation.URL) throws -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func getHeaderValue(httpMethod: Swift.String, url: Foundation.URL, nonce: Swift.String? = nil, accessToken: Swift.String? = nil) throws -> Swift.String
  #endif
  @objc deinit
}
public enum CryptoImportError : Swift.Error, Swift.CustomDebugStringConvertible {
  case invalidPath(_: Swift.String)
  case invalidPEMString(_: Swift.String, cause: (any Swift.Error)?)
  case invalidPassphrase
  case invalidType(_: Swift.String)
  case outOfBounds
  case failedToImport(_: Swift.String)
  public var debugDescription: Swift.String {
    get
  }
}
public struct RiskAssessmentConfiguration : Swift.Equatable, Swift.Sendable {
  public init(operatingSystemName: Swift.String, operatingSystemVersion: Swift.String, deviceModelName: Swift.String, applicatonIdentifier: Swift.String)
  public static func == (a: IdsvrHaapiDriver.RiskAssessmentConfiguration, b: IdsvrHaapiDriver.RiskAssessmentConfiguration) -> Swift.Bool
}
@objc @_hasMissingDesignatedInitializers @available(iOS 14, *)
@objcMembers public class HaapiTokenResult : ObjectiveC.NSObject {
  @objc final public let dPopAccessTokenInfo: IdsvrHaapiDriver.DpopAccessTokenInfo?
  @objc final public let error: (any Swift.Error)?
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @available(iOS 14.0, *)
final public class HaapiTokenManager : ObjectiveC.NSObject, Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  final public var dpop: IdsvrHaapiDriver.Dpop? {
    get
  }
  #endif
  @objc deinit
}
@available(iOS 14.0, *)
extension IdsvrHaapiDriver.HaapiTokenManager {
  @objc final public func createClient() -> IdsvrHaapiDriver.HaapiClient
  #if compiler(>=5.3) && $NonescapableTypes
  @available(swift, deprecated: 1.0, obsoleted: 1.0, message: "Objective-c will not be supported in the next major version")
  @objc final public func getHaapiToken(forceFresh: Swift.Bool = false, dpopNonce: Swift.String? = nil, completionHandler: @escaping @Sendable (IdsvrHaapiDriver.DpopAccessTokenInfo?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(swift, deprecated: 1.0, obsoleted: 1.0, message: "Objective-c will not be supported in the next major version")
  @objc final public func getHaapiToken(forceFresh: Swift.Bool = false, completionHandler: @escaping @Sendable (IdsvrHaapiDriver.DpopAccessTokenInfo?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) final public func getHaapiTokenAsync(forceFresh: Swift.Bool = false, dpopNonce: Swift.String? = nil) async throws -> IdsvrHaapiDriver.DpopAccessTokenInfo
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "This function will not be supported in the next major version. Please use getHaapiTokenAsync")
  final public func getHaapiToken(forceFresh: Swift.Bool = false, dpopNonce: Swift.String? = nil, completionHandler: @escaping @Sendable (Swift.Result<IdsvrHaapiDriver.DpopAccessTokenInfo, IdsvrHaapiDriver.HaapiError>) -> Swift.Void)
  #endif
  @objc final public func close()
  @objc final public func clearState()
}
@available(iOS 14, *)
public enum HttpHeaderNames {
  public static let accept: Swift.String
  public static let authorization: Swift.String
  public static let contentType: Swift.String
  public static let dpop: Swift.String
  public static let haapiSessionId: Swift.String
  public static let haapiSetSessionId: Swift.String
  public static let dpopNonce: Swift.String
  public static let wwwAuthenticate: Swift.String
  public static let clientInfo: Swift.String
}
@available(iOS 14, *)
public enum MimeTypes : Swift.String {
  case happi
  case json
  case xWwwFormUrlEncoded
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  @available(iOS 14, *)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc public enum CryptoKeyType : Swift.Int, Swift.RawRepresentable, Swift.Sendable {
  case p256
  case secureEnclave
  case security
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, *)
@objc public protocol TokenBoundConfiguration : Swift.Sendable {
  @objc var keyPairType: IdsvrHaapiDriver.CryptoKeyType { get }
}
@_inheritsConvenienceInitializers @available(iOS 14.0, *)
@objc final public class UnboundedTokenConfiguration : ObjectiveC.NSObject, IdsvrHaapiDriver.TokenBoundConfiguration {
  @objc final public let keyPairType: IdsvrHaapiDriver.CryptoKeyType
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 14.0, *)
@objc final public class BoundedTokenConfiguration : ObjectiveC.NSObject, IdsvrHaapiDriver.TokenBoundConfiguration {
  @objc final public let keyPairType: IdsvrHaapiDriver.CryptoKeyType
  @objc public init(keyPairType: IdsvrHaapiDriver.CryptoKeyType = .secureEnclave)
  @objc deinit
}
@available(iOS 14, *)
public enum StorageError : Swift.Error {
  case writeError(cause: any Swift.Error)
  case readError(cause: any Swift.Error)
  case deleteError(cause: any Swift.Error)
}
@available(iOS 14, *)
extension IdsvrHaapiDriver.StorageError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
@available(iOS 14, *)
public protocol Storage : Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  func read(key: Swift.String) throws -> Foundation.Data?
  #endif
  func write(key: Swift.String, data: Foundation.Data) throws
  func delete(key: Swift.String) throws
}
public enum DriverFollowUpTag : Swift.String, IdsvrHaapiDriver.FollowUpTag, Swift.CaseIterable {
  case flow
  case storage
  case http
  case attestation
  public var subsystem: Swift.String {
    get
  }
  public var tagName: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias AllCases = [IdsvrHaapiDriver.DriverFollowUpTag]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [IdsvrHaapiDriver.DriverFollowUpTag] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 14, *)
extension Foundation.URLResponse {
  #if compiler(>=5.3) && $NonescapableTypes
  public func haapiSessionId() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func dpopNonce() -> Swift.String?
  #endif
}
@available(iOS 14, *)
extension Foundation.URLRequest {
  public mutating func addAuthorizationHeader(headerValue: Swift.String)
  public mutating func addDpopHeader(headerValue: Swift.String)
  public mutating func addClientInfoHeader(headerValue: Swift.String)
  public mutating func addDpopAccessTokenHeaders(from dpopAccessTokenInfo: IdsvrHaapiDriver.DpopAccessTokenInfo, httpMethod: Swift.String, url: Foundation.URL) throws
  public mutating func addHaapiMediaTypeAcceptHeader()
  public mutating func addHaapiSessionIdHeader(_ sessionId: Swift.String)
}
@objc public protocol ClientAuthenticationMethod : Swift.Sendable {
}
@objc @_inheritsConvenienceInitializers final public class ClientAuthenticationMethodNone : ObjectiveC.NSObject, IdsvrHaapiDriver.ClientAuthenticationMethod {
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class ClientAuthenticationMethodSecret : ObjectiveC.NSObject, IdsvrHaapiDriver.ClientAuthenticationMethod {
  @objc public init(secret: Swift.String)
  @objc deinit
}
@objc @available(iOS 14.0, *)
final public class KeyPinning : ObjectiveC.NSObject, Swift.Sendable {
  @objc public init(hostname: Swift.String, publicKeyHash: Swift.String)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @available(iOS 14.0, *)
final public class ClientAuthenticationMethodMTLS : ObjectiveC.NSObject, IdsvrHaapiDriver.ClientAuthenticationMethod {
  @objc convenience public init(pkcs12Filename: Swift.String, pkcs12Passphrase: Swift.String, serverPEMFilename: Swift.String, isValidatingHostname: Swift.Bool, bundle: Foundation.Bundle = Bundle.main) throws
  @objc convenience public init(pkcs12Filename: Swift.String, pkcs12Passphrase: Swift.String, serverKeyPinnings: [IdsvrHaapiDriver.KeyPinning], bundle: Foundation.Bundle = Bundle.main) throws
  @objc deinit
}
@available(iOS 14.0, *)
@objc public enum JWTAsymmetricAlgorithm : Swift.Int, Swift.CaseIterable, Swift.Sendable {
  case rs256
  case rs384
  case rs512
  case ps256
  case ps384
  case ps512
  case es256
  case es384
  case es512
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  @available(iOS 14.0, *)
  public typealias AllCases = [IdsvrHaapiDriver.JWTAsymmetricAlgorithm]
  @available(iOS 14.0, *)
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [IdsvrHaapiDriver.JWTAsymmetricAlgorithm] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc @available(iOS 14.0, *)
final public class ClientAuthenticationMethodJWTAsymmetric : ObjectiveC.NSObject, IdsvrHaapiDriver.ClientAuthenticationMethod, Swift.Sendable {
  final public let signatureAlgorithm: IdsvrHaapiDriver.JWTAsymmetricAlgorithm
  nonisolated(unsafe) final public let privateKey: Security.SecKey
  @objc public init(pemFilename: Swift.String, signatureAlgorithm: IdsvrHaapiDriver.JWTAsymmetricAlgorithm, bundle: Foundation.Bundle = Bundle.main) throws
  @objc deinit
}
@available(iOS 14.0, *)
@objc public enum JWTSymmetricAlgorithm : Swift.Int, Swift.CaseIterable, Swift.Sendable {
  case hs256
  case hs384
  case hs512
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  @available(iOS 14.0, *)
  public typealias AllCases = [IdsvrHaapiDriver.JWTSymmetricAlgorithm]
  @available(iOS 14.0, *)
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [IdsvrHaapiDriver.JWTSymmetricAlgorithm] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc @available(iOS 14.0, *)
final public class ClientAuthenticationMethodJWTSymmetric : ObjectiveC.NSObject, IdsvrHaapiDriver.ClientAuthenticationMethod {
  final public let signatureAlgorithm: IdsvrHaapiDriver.JWTSymmetricAlgorithm
  final public let secretKey: Swift.String
  @objc public init(signatureAlgorithm: IdsvrHaapiDriver.JWTSymmetricAlgorithm, secretKey: Swift.String)
  @objc deinit
}
@available(iOS 14, *)
public struct ResponseAndData : Swift.Sendable {
  public let response: Foundation.URLResponse
  public let data: Foundation.Data?
}
@objc @_hasMissingDesignatedInitializers @available(iOS 14.0, *)
public class HaapiClient : ObjectiveC.NSObject, @unchecked Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  public var dpop: IdsvrHaapiDriver.Dpop? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "This function will not be supported in the next major version. Please use async performDataTask")
  public func performDataTask(for urlRequest: Foundation.URLRequest, completionHandler: @escaping @Sendable (Swift.Result<IdsvrHaapiDriver.ResponseAndData, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  nonisolated(nonsending) public func performDataTask(for urlRequest: Foundation.URLRequest) async throws -> IdsvrHaapiDriver.ResponseAndData
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(swift, deprecated: 1.0, obsoleted: 1.0, message: "Objective-c will not be supported in the next major version")
  @objc public func performDataTask(for urlRequest: Foundation.URLRequest, completionHandler: @escaping @Sendable (Foundation.Data?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void)
  #endif
  @objc deinit
}
@available(iOS 14.0, *)
extension IdsvrHaapiDriver.CryptoKeyType : Swift.Codable {
}
public enum RetryCondition {
  case now
  case whenAppInForeground
  public static func == (a: IdsvrHaapiDriver.RetryCondition, b: IdsvrHaapiDriver.RetryCondition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum UnrecoverableAction : Swift.Equatable {
  case modifyConfiguration(reason: Swift.String)
  case introspectCause
  case invalidPlatform
  public static func == (a: IdsvrHaapiDriver.UnrecoverableAction, b: IdsvrHaapiDriver.UnrecoverableAction) -> Swift.Bool
}
public enum IdsvrErrorHandling {
  case retryable(condition: IdsvrHaapiDriver.RetryCondition)
  case newHaapiFlow
  case unrecoverable(action: IdsvrHaapiDriver.UnrecoverableAction)
}
public protocol IdsvrError : Swift.Error {
  var error: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var errorDescription: Swift.String? { get }
  #endif
  var failureReason: Swift.String { get }
  var recoverySuggestion: IdsvrHaapiDriver.IdsvrErrorHandling { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var cause: (any Swift.Error)? { get }
  #endif
}
@objc @_hasMissingDesignatedInitializers @available(iOS 14, *)
@objcMembers final public class AccessToken : ObjectiveC.NSObject, Swift.Sendable {
  @objc final public let value: Swift.String
  @objc final public let expiresOn: Foundation.Date
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override final public var debugDescription: Swift.String {
    @objc get
  }
  @objc final public func isValid(atTime: Foundation.Date, minTtl: Foundation.TimeInterval) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @available(iOS 14, *)
@objcMembers final public class DpopAccessTokenInfo : ObjectiveC.NSObject, Swift.Sendable {
  @objc final public let accessToken: IdsvrHaapiDriver.AccessToken
  @objc final public let dpop: IdsvrHaapiDriver.Dpop
  @objc final public let dpopNonce: Swift.String?
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override final public var debugDescription: Swift.String {
    @objc get
  }
  @objc final public func dpopHeaderValue(httpMethod: Swift.String, url: Foundation.URL) throws -> Swift.String
  @objc final public func authorizationHeaderValue() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class HaapiLogger : ObjectiveC.NSObject {
  public static var followUpTags: [any IdsvrHaapiDriver.FollowUpTag] {
    get
    set
  }
  @objc public static var isDebugEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static var isInfoEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static var isWarningEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static var isErrorEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static var isSensitiveValueMasked: Swift.Bool {
    @objc get
    @objc set
  }
  public static func appendLogSink(_ logSink: any IdsvrHaapiDriver.LogSink)
  @objc deinit
}
public enum LogType : Swift.String {
  case debug
  case error
  case info
  case warning
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol LogSink : Swift.Sendable {
  func writeLog(logType: IdsvrHaapiDriver.LogType, followUpTag: any IdsvrHaapiDriver.FollowUpTag, message: Swift.String, file: Swift.String, line: Swift.Int)
}
public protocol FollowUpTag : Swift.Sendable {
  var subsystem: Swift.String { get }
  var tagName: Swift.String { get }
}
@objc @available(iOS 14.0, *)
@objcMembers public class HaapiTokenManagerBuilder : ObjectiveC.NSObject {
  @objc public init(tokenEndpoint: Foundation.URL, clientId: Swift.String)
  @objc @discardableResult
  public func setName(_ name: Swift.String) -> IdsvrHaapiDriver.HaapiTokenManagerBuilder
  @objc @discardableResult
  public func setInternalUrlSession(_ urlSession: Foundation.URLSession) -> IdsvrHaapiDriver.HaapiTokenManagerBuilder
  @objc @discardableResult
  public func setHaapiTokenMinTtl(_ minTtl: Foundation.TimeInterval) -> IdsvrHaapiDriver.HaapiTokenManagerBuilder
  @objc @discardableResult
  public func disableDeviceCheckAttestation() -> IdsvrHaapiDriver.HaapiTokenManagerBuilder
  @objc @discardableResult
  public func setAttestationMaxRetryCount(maxRetries: Swift.Int) -> IdsvrHaapiDriver.HaapiTokenManagerBuilder
  @objc @discardableResult
  public func setTokenBoundConfiguration(config: any IdsvrHaapiDriver.TokenBoundConfiguration) -> IdsvrHaapiDriver.HaapiTokenManagerBuilder
  @objc @discardableResult
  public func setClientAuthenticationMethod(method: any IdsvrHaapiDriver.ClientAuthenticationMethod) -> IdsvrHaapiDriver.HaapiTokenManagerBuilder
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @discardableResult
  @available(*, unavailable, renamed: "setRiskAssessmentConfiguration(_:)", message: "Use setRiskAssessmentConfiguration(_:) instead.")
  public func setApplicationBundle(_ bundle: Foundation.Bundle?) -> IdsvrHaapiDriver.HaapiTokenManagerBuilder
  #endif
  @discardableResult
  public func setRiskAssessmentConfiguration(_ configuration: IdsvrHaapiDriver.RiskAssessmentConfiguration) -> IdsvrHaapiDriver.HaapiTokenManagerBuilder
  @objc public func build() throws -> IdsvrHaapiDriver.HaapiTokenManager
  @objc deinit
}
@available(iOS 14, *)
extension IdsvrHaapiDriver.MimeTypes : Swift.Equatable {}
@available(iOS 14, *)
extension IdsvrHaapiDriver.MimeTypes : Swift.Hashable {}
@available(iOS 14, *)
extension IdsvrHaapiDriver.MimeTypes : Swift.RawRepresentable {}
extension IdsvrHaapiDriver.CryptoKeyType : Swift.Equatable {}
extension IdsvrHaapiDriver.CryptoKeyType : Swift.Hashable {}
extension IdsvrHaapiDriver.DriverFollowUpTag : Swift.Equatable {}
extension IdsvrHaapiDriver.DriverFollowUpTag : Swift.Hashable {}
extension IdsvrHaapiDriver.DriverFollowUpTag : Swift.RawRepresentable {}
@available(iOS 14.0, *)
extension IdsvrHaapiDriver.JWTAsymmetricAlgorithm : Swift.Equatable {}
@available(iOS 14.0, *)
extension IdsvrHaapiDriver.JWTAsymmetricAlgorithm : Swift.Hashable {}
@available(iOS 14.0, *)
extension IdsvrHaapiDriver.JWTAsymmetricAlgorithm : Swift.RawRepresentable {}
@available(iOS 14.0, *)
extension IdsvrHaapiDriver.JWTSymmetricAlgorithm : Swift.Equatable {}
@available(iOS 14.0, *)
extension IdsvrHaapiDriver.JWTSymmetricAlgorithm : Swift.Hashable {}
@available(iOS 14.0, *)
extension IdsvrHaapiDriver.JWTSymmetricAlgorithm : Swift.RawRepresentable {}
extension IdsvrHaapiDriver.RetryCondition : Swift.Equatable {}
extension IdsvrHaapiDriver.RetryCondition : Swift.Hashable {}
extension IdsvrHaapiDriver.LogType : Swift.Equatable {}
extension IdsvrHaapiDriver.LogType : Swift.Hashable {}
extension IdsvrHaapiDriver.LogType : Swift.RawRepresentable {}
